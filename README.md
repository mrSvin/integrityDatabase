## Реализация целостности БД MongoDB для платежной системы с помощью распределенной декомпозиции хэша

### Проблема, которую решает сервис
Если злоумышленник получил доступ к одной из двух нод и собственноручно изменит в ней данные, то сервис при проведении операции относительно определенного id проверит на валидность текущих полей по распределенному хэшу 2 нодах. Фактически сервис не позволит осуществить операцию при нарушенной целостности одного из полей к запрашиваемому id.

### Структура системы
2 ноды, в которых имеются изолированные БД.

Первая нода с БД с полями:
- id кошелька 
- баланс
- время последней операции
- hash (начальный хэш)

Вторая БД с полями:
- id кошелька
- hash (конечный хэш)

### Работа сервиса по обеспечению целостности
1.Сервис имеет четыре grpc эндпоинта:
- создание кошелька (создается только с нулевым балансом)
- удаление кошелька
- изменение баланса кошельков
- чтение баланса кошелька
2. При вызове эндпоинта на изменеие балансов, удаление кошелька, чтение баланса происходит такой алгоритм проверки целостности относительно определенного кошелька:
   1. В текущей ноде происходит чтение БД полей id, баланса, времени последней операции, к ним применяется расчет хэша
   2. Полученное значение считывается и сравнивается с конкатенируемым значением hex БД первой ноды и второй ноды по id, если не совпало, то реверт

### Тестирование системы с пакетной отправкой транзакций
1. Для тестирования системы необходимо установить локально MongoDB
2. Запустить интеграционный тест командой:
```
make transfer test
```

### Полученный бэнчмарк для 10.000 трансферов при отправке по одной транзакции (i7-10700 2.9GHz, 16GB RAM, SSD)
с логами в консоль 735 tps
без логов в консоль 769 tps

### Полученный бэнчмарк при пакетной отправки, количество трансферов в пакете 100 (i7-10700 2.9GHz, 16GB RAM, SSD) 
1562 tps

### 

### Возможные проблемы
#### 1. Восстановление данных при нарушении целостности.
#### Возможное решение:
Ведение в отдельной БД лога каждого изменения с фиксацией конечного хэша, что позволит по id кошелька по внешнему хэшу (конечный хэш в отдельной ноде) 
восстановить последнюю запись с корректной валидацией (с некорректными данными в логах это будет сделать невозможно, что исключит риск подделки логов).

БД лога транзакций:
- id кошелька
- тип операции
- время операции
- предыдущий баланс
- принятный новый баланс
- hash (начльный)

Данная база может быть размещена на второй ноде. Соотвественно сервис дполнительно пишет в эту базу изменения при положительной валидации.

#### 2. Отказоустойчивость, при отключении одной из нод.
#### Возможное решение:
Использовать кластеризацию для кадого контура базы, т.е. создать два независимых кластера, которые обслуживают свою БД.

#### 3. При выполнении транзакции в две ноды в одну из них коммит не прошел, а в другую прошел, вследствии чего возможен рассинхрон.
#### Возможное решение:
В сервисе при не подтверждении коммита одной из операции записи в базу в рамках одной операции внедрен механизм отката предыдущего состояния транзакции, в которой коммит был осуществлен.

#### 4. Проблема асинхронных вызовов. (Например 50 кошельков отправили трансфер другим 50 кошелькам одну сумму, а они обратно в это же время трансфер с другой суммой)
#### Возможное решение (реализовано):
Для пула транзакций используется очередь для последовательного выполнения групп транзакций и избегания блокировки БД. Получив сообщение с группой транзакций происходят 
последовательно данные этапы:
1. поиск пересекающихся транзакций (в этом пуле два кошелька отправили транзакции друг другу)
2. проверка о возможности этих трансферов на основании балансов 
3. на уровне сервиса по полученной группе трансферов рассчитывается конечный апдейт балансов кошельков
   (условно 1 кошелек отправляет 200 другому, другой ему кидает 100, в итоге вместо двух трансферов в виде 2 апдейтов будет один на 100 (+200-100))   
4. формируется перечень перерасчитанных балансов с уже уникальными кошельками 
5. по этому перечню запускаются апдейты в БД
6. по окончанию выполнения всех трансфер берется следующее сообщение пула транзакций с очереди и снова с этапа 1.
